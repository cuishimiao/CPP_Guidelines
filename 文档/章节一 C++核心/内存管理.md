
# 内存管理


---

### **内存管理大乱斗：手动 vs 智能指针**

#### **1. 手动内存分配（new/delete）—— 野生程序员の日常**
想象你养了一只电子宠物（内存），每天要手动喂食（`new`）和铲屎（`delete`）：

```cpp
// 领养一只叫"data"的宠物
int* pet = new int(42); // 喂食：分配内存
std::cout << *pet;      // 逗它玩
delete pet;             // 铲屎：释放内存（但经常忘！）
```

**适用场景**：
- 你**极度控制狂**（比如写嵌入式系统，内存精确到字节）。
- 需要**表演杂技**（比如自定义内存池、原地构造对象）。

**翻车现场**：
```cpp
int* pet = new int(42);
if (程序员.困了()) {
    return; // 忘记delete！宠物变成丧尸，内存泄漏！
}
```

---

#### **2. unique_ptr —— 霸道总裁の专属管家**
你买了一只限量版机械狗（资源），只能**独享**，但可以转交他人：

```cpp
auto bossDog = std::make_unique<Dog>("赛博哮天犬"); // 专属管家
// auto clone = bossDog; // 报错！禁止克隆总裁的狗
auto 秘书的狗 = std::move(bossDog); // 所有权转移，总裁的狗没了！
```

**适用场景**：
- **我的资源你别碰**（文件句柄、独占硬件）。
- **避免复制开销**（比如大型数据只传移动不复制）。

**潜规则**：
- 用 `std::move` 转交时，原指针会变成**空虚公子**（`nullptr`）。

---

#### **3. shared_ptr —— 合租室友の共享合约**
你和室友们合养了一只猫（资源），**最后一个搬走的人负责送走猫**：

```cpp
auto 猫 = std::make_shared<Cat>("喵仙人");
auto 室友A = 猫; // 合租协议+1（引用计数=2）
auto 室友B = 猫; // 合租协议+1（引用计数=3）
室友A.reset();   // 室友A搬走（计数=2）
室友B.reset();   // 室友B搬走（计数=1）
// 最后你reset时，猫被送回收容所（内存释放）
```

**适用场景**：
- **共享空调遥控器**（缓存、全局配置）。
- **复杂关系网**（多个对象引用同一数据）。

**翻车警告**：
```cpp
shared_ptr<人> 小明 = make_shared<人>();
shared_ptr<人> 小红 = make_shared<人>();
小明->暗恋 = 小红;
小红->暗恋 = 小明;
// 形成「死亡牵手」，引用计数永不归零，内存泄漏！
```

---

#### **4. weak_ptr —— 吃瓜群众の临时通行证**
你想去朋友家撸猫，但**不参与铲屎协议**（不影响猫的去留）：

```cpp
auto 猫 = std::make_shared<Cat>("喵仙人");
std::weak_ptr<Cat> 吃瓜群众 = 猫;

if (!吃瓜群众.expired()) { // 猫还在吗？
    auto 临时通行证 = 吃瓜群众.lock(); // 获取shared_ptr（计数+1）
    临时通行证->撸(); // 安全撸猫！
} // 临时通行证销毁（计数-1）
```

**适用场景**：
- **避免循环引用**（如小明小红互暗恋，改用weak_ptr）。
- **观察者模式**（查看资源是否存在，但不续命）。

---

### **总结：如何选择？**
| 场景 | 选择 | 类比 |
|------|------|------|
| **独裁统治**（明确唯一主人） | `unique_ptr` | 你的私人飞机，别人不能开 |
| **共享经济**（多人共用资源） | `shared_ptr` | 合租房的Wi-Fi |
| **围观群众**（临时访问资源） | `weak_ptr` | 去朋友家蹭饭但不洗碗 |
| **极限操作**（手动微调性能） | `new/delete` | 自己造火箭（但容易炸） |

**口诀**：
- 能搬走就别复制（`unique_ptr`优先）。
- 共享资源用合约（`shared_ptr`），但小心死亡牵手。
- 手动管理是底牌，除非你是扫地僧！

下次写C++时，让你的内存管理像吃火锅一样轻松 —— **该涮的涮，该扔的扔**！ 🍲🔧