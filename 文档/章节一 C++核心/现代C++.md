# 现代 C++（C++11/14/17/20）



---

### **Lambda 表达式、右值引用、constexpr、结构化绑定、模块：C++ 的「生活小妙招」**

---

#### **1. Lambda 表达式 —— 代码里的外卖小哥**
**比喻**：
想点个外卖（临时函数），但懒得下楼（写正式函数）？Lambda 是你的救星！

**代码版外卖**：
```cpp
auto 点外卖 = [](string 菜品) {
    std::cout << "骑手已接单：" << 菜品 << "，加辣！";
};

点外卖("螺蛳粉"); // 下单！
点外卖("奶茶");  // 再来一杯！
```

**功能扩展**：
- **捕获列表**（`[ ]`）：带什么装备去送外卖？
```cpp
int 私房钱 = 100;
auto 偷偷消费 = [私房钱]() {
    // 捕获私房钱（按值复制），但无法修改（默认const）
    std::cout << "花了 " << 私房钱 << " 买皮肤！";
};
偷偷消费();
```

**优势**：
- 就地定义，不用写全局函数（适合临时工）。
- 能捕获局部变量（外卖小哥知道你家地址）。

**翻车警告**：
```cpp
auto 危险操作 = [&私房钱]() { 私房钱 = 0; }; // 按引用捕获 → 私房钱真的会清零！
```

---

#### **2. 右值引用 —— 搬家公司的哲学**
**比喻**：
左值（有名字的变量）像房子，右值（临时值）像行李。
右值引用（`&&`）是搬家公司，直接「偷」行李资源，省去复制开销！

**代码版搬家**：
```cpp
std::string 旧家 = "一堆舍不得扔的垃圾";
std::string 新家 = std::move(旧家); // 搬家公司出动！

// 旧家现在空了（但可能残留一些「灵魂」）
std::cout << 旧家; // 输出可能是空字符串（但别依赖它！）
```

**适用场景**：
- 避免大对象深拷贝（比如 `vector`、`string`）。
- 实现移动构造函数、移动赋值（高性能必备）。

**潜规则**：
- 用了 `std::move` 后，原对象可能变成「丧尸」（能析构，但内容不确定）。
- 不要对左值随便 `std::move`，否则你的代码会变成「凶宅」！

---

#### **3. `constexpr` —— 编译期的微波炉**
**比喻**：
普通代码是生米煮成熟饭（运行时计算），`constexpr` 是微波炉，**编译时直接加热**！

**代码版微波炉**：
```cpp
constexpr int 加热时间(int 秒) {
    return 秒 * 1000; // 编译时算出毫秒数
}

int 煮饭时间 = 加热时间(5); // 编译完直接是 5000
std::array<int, 加热时间(3)> 米饭; // 数组大小在编译期确定
```

**C++14/17 增强**：
- 支持更复杂的逻辑（`if`、循环）。
```cpp
constexpr auto 做菜(bool 加盐) {
    if constexpr (加盐) return "咸了";
    else return "淡了";
}
// 编译时直接生成两种结果，运行时零开销！
```

**优势**：
- 性能拉满（结果直接写在二进制里）。
- 替代宏（比如计算哈希值、数学常量）。

**翻车警告**：
```cpp
constexpr int 炸厨房() {
    return std::rand(); // 错误！编译期不能调用运行时函数
}
```

---

#### **4. 结构化绑定 —— 拆快递の快乐**
**比喻**：
函数返回一个包裹（结构体/元组），结构化绑定帮你一口气拆开所有小物件！

**代码版拆快递**：
```cpp
auto 买买买() {
    return std::tuple("手机", 5999, "红色"); // 商品名、价格、颜色
}

auto [商品, 价格, 颜色] = 买买买(); // 一键拆包！
std::cout << "又花了 " << 价格 << " 买了个 " << 颜色 << 商品;
```

**适用场景**：
- 处理多返回值函数（比如返回坐标 `x, y, z`）。
- 遍历 `map`（直接拆成 `[key, value]`）。
```cpp
std::map<std::string, int> 库存 = {{"可乐", 5}, {"薯片", 3}};
for (const auto& [商品, 数量] : 库存) {
    std::cout << 商品 << "只剩" << 数量 << "袋！";
}
```

**潜规则**：
- 绑定变量是**副本**或**引用**（取决于 `auto&` 或 `auto`）。
- 不支持部分拆包（要么全拆，要么不拆）。

---

#### **5. 模块（C++20 `modules`） —— 告别「头文件地狱」**
**比喻**：
以前写代码像在垃圾堆里找头文件（`#include`），模块化是请了收纳师，把代码整理成「乐高积木」！

**代码版收纳**：
```cpp
// 旧世界（头文件地狱）
#include <vector>
#include <string>
#include "神秘头文件.h" // 谁也不知道它包含了啥

// 新世界（模块乐高）
import std.core;         // 标准库模块
import 我的工具箱;       // 自定义模块
```

**优势**：
- **编译加速**：模块只编译一次，不用重复解析头文件。
- **减少名称冲突**：不用再怕 `#define` 的魔法攻击！
- **显式导出**：只有声明为 `export` 的部分才能被外部使用。

**定义模块示例**：
```cpp
// 我的工具箱.cpp
export module 我的工具箱;

export int 加薪(int 工资) {
    return 工资 * 2; // 老板：这段代码不存在
}
```

**使用模块**：
```cpp
import 我的工具箱;
std::cout << 加薪(5000); // 输出 10000（梦里什么都有）
```

---

### **总结：C++ 生活指南**
| 特性 | 作用 | 类比 | 注意事项 |
|------|------|------|----------|
| **Lambda** | 就地定义函数 | 外卖小哥 | 小心捕获变量 |
| **右值引用** | 移动资源 | 搬家公司 | 别乱动左值 |
| **`constexpr`** | 编译期计算 | 微波炉 | 只支持简单操作 |
| **结构化绑定** | 拆解返回值 | 拆快递 | 不能拆一半 |
| **模块** | 替代头文件 | 收纳师 | 需要C++20支持 |

**口诀**：
- Lambda 是临时工，右值引用偷资源。
- 编译微波用 `constexpr`，拆快递用结构化。
- 模块告别 `#include`，代码清爽乐开花！

下次写代码时，愿你像大厨一样 —— **用对的工具，做香的代码**！ 🍳👨💻