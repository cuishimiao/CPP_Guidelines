
# 多线程与并发



### **多线程の奇妙冒险：从群魔乱舞到秩序之光**



#### **1. `std::thread` —— 开分公司の老板行为**
**比喻**：
你是一家公司老板（主线程），突然想开分公司（子线程）。
但分公司一开业就放飞自我，可能在你喝茶时疯狂输出！

```cpp
void 分公司的任务() {
    std::cout << "分公司的KPI：摸鱼中";
}

int main() {
    std::thread 分公司(分公司的任务); // 开张！
    std::cout << "主线程：假装在监工";
  
    // 必须二选一：
    分公司.join();  // 等分公司倒闭（同步）
    // 分公司.detach(); // 放养分公司（主线程跑路，风险自负！）
}
```

**适用场景**：
- **简单任务分叉**（比如同时下载10个文件）。
- **不怕死机**（反正代码不是你维护）。

**翻车现场**：
```cpp
std::thread 分公司(摸鱼函数);
main函数直接return; // 主线程跑路，分公司还在摸鱼 → 程序爆炸！
```

---

#### **2. 锁（`mutex`） —— 抢厕所の哲学问题**
**比喻**：
多个线程像一群憋急的人，争抢唯一厕所（共享资源）。
锁（`mutex`）是厕所门上的牌子：「有人/无人」。

```cpp
std::mutex 厕所门;
int 厕所库存 = 1; // 唯一坑位

void 憋急的程序员() {
    std::lock_guard<std::mutex> 锁(厕所门); // 自动抢锁
    厕所库存--; // 用厕所
    // 离开时锁自动释放（RAII魔法）
}

int main() {
    std::thread 程序员1(憋急的程序员);
    std::thread 程序员2(憋急的程序员);
    // 如果不加锁，两人同时进厕所 → 库存变-1，逻辑混乱！
}
```

**适用场景**：
- **共享资源保护**（全局变量、文件写入）。
- **避免数据踩踏事故**（比如多个线程改同一个数组）。

**潜规则**：
- 用 `lock_guard` 或 `unique_lock`（RAII包装），**避免手动 `lock/unlock`**（否则容易忘解锁，变成「永恒厕所」）。
- 小心死锁：A等B的锁，B等A的锁 → 一起憋到天荒地老💀。

---

#### **3. 原子操作（`atomic`） —— 自动售货机の优雅**
**比喻**：
原子变量像自动售货机，投币→出货一气呵成，**没有中间商赚差价**（无竞争状态）。

```cpp
std::atomic<int> 售货机库存(10); // 原子整数

void 买家() {
    售货机库存--; // 不用抢锁，自带「防多人乱摸」
}

void 黄牛() {
    // 售货机库存++的同时返回旧值（原子操作套餐）
    int 抢到的 = 售货机库存.fetch_add(1);
}
```

**适用场景**：
- **简单共享变量**（计数器、标志位）。
- **高性能场景**（比mutex轻量，但只能处理基本类型）。

**翻车警告**：
```cpp
std::atomic<大型结构体> 大象; // 原子操作不支持复杂类型！
大象.腿 = 4; // 这不是原子操作！会被其他线程打断！
```

---

#### **4. 异步（`future/promise`） —— 外卖订单の信任游戏**
**比喻**：
- **`promise`**：你下单外卖时，店家给你一张小票（承诺）。
- **`future`**：小票上说「30分钟后凭此取餐」。

```cpp
std::future<std::string> 下单麻辣烫() {
    std::promise<std::string> 外卖单;
    auto 小票 = 外卖单.get_future();

    std::thread 外卖小哥([&] {
        std::this_thread::sleep_for(3s); // 假装送餐
        外卖单.set_value("麻酱+香菜"); // 送达！
    });
    外卖小哥.detach(); // 放养小哥

    return 小票;
}

int main() {
    auto 小票 = 下单麻辣烫();
    std::cout << "先打局游戏...";
    std::string 外卖 = 小票.get(); // 阻塞直到外卖到达
}
```

**适用场景**：
- **耗时操作后台执行**（计算、IO操作）。
- **需要获取异步结果**（比如并行计算后汇总）。

**潜规则**：
- `future.get()` 只能调用一次，**第二次会拿到空气**！
- 用 `std::async` 更简单（自动管理线程）：
```cpp
auto 小票 = std::async([] { return "不用手写promise！"; });
```

---

### **总结：多线程生存指南**
| 工具 | 作用 | 类比 | 警告 |
|------|------|------|------|
| **`std::thread`** | 开线程 | 开分公司 | 记得join/detach，否则原地爆炸 |
| **`mutex`** | 保护共享资源 | 抢厕所 | 死锁比忘带纸更可怕 |
| **`atomic`** | 无锁简单操作 | 自动售货机 | 只卖饮料，不卖满汉全席 |
| **`future/promise`** | 异步拿结果 | 外卖订单 | 别把外卖小票弄丢了 |

**多线程の终极奥义**：
- 能不用锁就别用（原子操作或设计无共享结构）。
- 线程不是越多越好（一核有难，八核围观）。
- 异步代码像恋爱 —— **不要随便承诺（promise），但承诺了就要兑现**！

下次写多线程时，愿你像交响乐指挥一样 —— **让每个线程在正确的时间奏响正确的音符**！ 🎻🎹