

# å®ç°ä¸€ä¸ªå†…å­˜æ± ã€çº¿ç¨‹æ± æˆ–ç½‘ç»œåº“ï¼ˆå‚è€ƒ muduoï¼‰

---

### **C++ é«˜æ€§èƒ½ç»„ä»¶å®ç°æŒ‡å—ï¼šä»å†…å­˜æ± åˆ°ç½‘ç»œåº“ â€”â€” æ·±å…¥åº•å±‚ï¼ŒæŒæ§æ€§èƒ½å‘½è„‰**

---

#### **1. å†…å­˜æ± ï¼ˆMemory Poolï¼‰â€”â€” çªç ´ç³»ç»Ÿåˆ†é…å™¨çš„æ€§èƒ½ç“¶é¢ˆ**
**è®¾è®¡ç›®æ ‡**ï¼š
- å‡å°‘ `malloc/free` çš„ç³»ç»Ÿè°ƒç”¨å¼€é”€
- é¿å…å†…å­˜ç¢ç‰‡åŒ–
- æ”¯æŒçº¿ç¨‹å®‰å…¨çš„å¿«é€Ÿåˆ†é…

**æ ¸å¿ƒæ¶æ„**ï¼š
```
+-------------------+
|    MemoryPool     |
|-------------------|
| + allocate()      |
| + deallocate()    |
|-------------------|
| - chunk_list_     | â†’ å†…å­˜å—é“¾è¡¨
| - free_list_      | â†’ ç©ºé—²æ§½ä½æ ˆ
+-------------------+
```

**é«˜æ•ˆå®ç°æŠ€å·§**ï¼š
```cpp
// åŸºäºå›ºå®šå¤§å°å—çš„å†…å­˜æ± 
class MemoryPool {
public:
    explicit MemoryPool(size_t block_size, size_t chunk_count = 1024)
        : block_size_(block_size),
          chunk_count_(chunk_count),
          free_list_(nullptr) {
        AllocateNewChunk();
    }

    void* Allocate() {
        if (!free_list_) {
            AllocateNewChunk();
        }
        void* ptr = free_list_;
        free_list_ = *(void**)free_list_; // ç©ºé—²é“¾è¡¨æŒ‡é’ˆè·³è·ƒ
        return ptr;
    }

    void Deallocate(void* ptr) {
        *(void**)ptr = free_list_;
        free_list_ = ptr;
    }

private:
    void AllocateNewChunk() {
        char* chunk = new char[block_size_ * chunk_count_];
        chunks_.push_back(chunk);

        // å°†æ–°å—å†…å­˜åŠ å…¥ç©ºé—²é“¾è¡¨
        for (size_t i = 0; i < chunk_count_; ++i) {
            void* ptr = chunk + i * block_size_;
            Deallocate(ptr); // åˆ©ç”¨Deallocateæ„å»ºé“¾è¡¨
        }
    }

    size_t block_size_;
    size_t chunk_count_;
    void* free_list_;
    std::vector<char*> chunks_;
};

// ä½¿ç”¨ç¤ºä¾‹ï¼š
MemoryPool pool(sizeof(MyClass), 2048);
MyClass* obj = new(pool.Allocate()) MyClass();
obj->~MyClass();
pool.Deallocate(obj);
```

**æ€§èƒ½ä¼˜åŒ–ç‚¹**ï¼š
- **çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼ˆTLSï¼‰**ï¼šæ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹å†…å­˜æ± ï¼Œæ¶ˆé™¤é”ç«äº‰
- **å¯¹é½ä¼˜åŒ–**ï¼šä½¿ç”¨ `alignas(64)` ä¿è¯ç¼“å­˜è¡Œå¯¹é½
- **æ‰¹é‡é¢„åˆ†é…**ï¼šæå‰åˆ†é…å¤§å—å†…å­˜å‡å°‘ç³»ç»Ÿè°ƒç”¨

---

#### **2. çº¿ç¨‹æ± ï¼ˆThread Poolï¼‰â€”â€” é«˜æ•ˆä»»åŠ¡è°ƒåº¦å¼•æ“**
**è®¾è®¡è¦ç‚¹**ï¼š
- æ— é”ä»»åŠ¡é˜Ÿåˆ—ï¼ˆåŸºäº `std::atomic` å’Œ CAS æ“ä½œï¼‰
- å·¥ä½œçº¿ç¨‹è´Ÿè½½å‡è¡¡
- ä¼˜é›…å…³é—­æœºåˆ¶

**é«˜æ€§èƒ½å®ç°**ï¼š
```cpp
class ThreadPool {
public:
    explicit ThreadPool(size_t thread_count = std::thread::hardware_concurrency())
        : stop_(false) {
        for (size_t i = 0; i < thread_count; ++i) {
            workers_.emplace_back([this] {
                for (;;) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(mutex_);
                        condition_.wait(lock, [this] {
                            return stop_ || !tasks_.empty();
                        });
                        if (stop_ && tasks_.empty()) return;
                        task = std::move(tasks_.front());
                        tasks_.pop();
                    }
                    task();
                }
            });
        }
    }

    template<class F, class... Args>
    auto Enqueue(F&& f, Args&&... args) -> std::future<decltype(f(args...))> {
        using ReturnType = decltype(f(args...));
        auto task = std::make_shared<std::packaged_task<ReturnType()>>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)...)
        );

        std::future<ReturnType> res = task->get_future();
        {
            std::unique_lock<std::mutex> lock(mutex_);
            if (stop_) throw std::runtime_error("enqueue on stopped pool");
            tasks_.emplace([task] { (*task)(); });
        }
        condition_.notify_one();
        return res;
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(mutex_);
            stop_ = true;
        }
        condition_.notify_all();
        for (auto& worker : workers_) {
            worker.join();
        }
    }

private:
    std::vector<std::thread> workers_;
    std::queue<std::function<void()>> tasks_;
    std::mutex mutex_;
    std::condition_variable condition_;
    bool stop_;
};

// ä½¿ç”¨ç¤ºä¾‹ï¼š
ThreadPool pool(4);
auto future = pool.Enqueue([](int a, int b) { return a + b; }, 2, 3);
std::cout << future.get(); // è¾“å‡º5
```

**è¿›é˜¶ä¼˜åŒ–**ï¼š
- **ä»»åŠ¡çªƒå–ï¼ˆWork Stealingï¼‰**ï¼šå…è®¸ç©ºé—²çº¿ç¨‹ä»å…¶ä»–çº¿ç¨‹é˜Ÿåˆ—çªƒå–ä»»åŠ¡
- **ä¼˜å…ˆçº§é˜Ÿåˆ—**ï¼šæ”¯æŒé«˜ä¼˜å…ˆçº§ä»»åŠ¡æ’é˜Ÿ
- **æ— é”é˜Ÿåˆ—**ï¼šåŸºäº `boost::lockfree::queue` æˆ–è‡ªæ—‹é”

---

#### **3. ç½‘ç»œåº“ï¼ˆå‚è€ƒ muduoï¼‰â€”â€” Reactor æ¨¡å¼çš„é«˜å¹¶å‘å®è·µ**
**æ ¸å¿ƒæ¶æ„**ï¼š
```
+-------------------+        +-----------------+
|   EventLoop       | â†----- |   Channel       |
|-------------------|        |-----------------|
| - poller_         |        | - fd_           |
| - active_channels_|        | - events_       |
| - timer_queue_    |        | - callback_     |
+-------------------+        +-----------------+
         â†‘
         | ç®¡ç†
+-------------------+
|   TcpServer       |
|-------------------|
| - acceptor_       |
| - connection_map_ |
+-------------------+
```

**å…³é”®ç»„ä»¶å®ç°**ï¼š
```cpp
// Reactor æ ¸å¿ƒï¼šäº‹ä»¶å¾ªç¯
class EventLoop {
public:
    void Loop() {
        while (!quit_) {
            active_channels_.clear();
            poller_->Poll(1000, &active_channels_);
            for (Channel* ch : active_channels_) {
                ch->HandleEvent();
            }
            ProcessPendingTasks();
        }
    }

    void RunInLoop(std::function<void()> cb) {
        if (IsInLoopThread()) {
            cb();
        } else {
            AddPendingTask(std::move(cb));
        }
    }

private:
    std::unique_ptr<Poller> poller_;
    std::vector<Channel*> active_channels_;
    std::thread::id owner_thread_id_;
    std::atomic<bool> quit_{false};
};

// TCP è¿æ¥ç®¡ç†
class TcpConnection : noncopyable {
public:
    TcpConnection(EventLoop* loop, int sockfd)
        : loop_(loop),
          channel_(new Channel(loop, sockfd)) {
        channel_->SetReadCallback([this] { HandleRead(); });
        channel_->EnableReading();
    }

    void Send(const std::string& msg) {
        if (loop_->IsInLoopThread()) {
            WriteInLoop(msg);
        } else {
            loop_->RunInLoop([this, msg] { WriteInLoop(msg); });
        }
    }

private:
    void HandleRead() {
        char buf[65536];
        ssize_t n = read(channel_->fd(), buf, sizeof(buf));
        if (n > 0) {
            input_buffer_.append(buf, n);
            message_callback_(shared_from_this(), &input_buffer_);
        }
    }

    EventLoop* loop_;
    std::unique_ptr<Channel> channel_;
    Buffer input_buffer_;
};

// æœåŠ¡å™¨å…¥å£
class TcpServer {
public:
    TcpServer(EventLoop* loop, const InetAddress& addr)
        : loop_(loop),
          acceptor_(new Acceptor(loop, addr)) {
        acceptor_->SetNewConnectionCallback([this](int sockfd) {
            EventLoop* io_loop = thread_pool_->GetNextLoop();
            io_loop->RunInLoop([=] {
                TcpConnectionPtr conn(new TcpConnection(io_loop, sockfd));
                connections_[sockfd] = conn;
            });
        });
    }

private:
    EventLoop* loop_;
    std::unique_ptr<Acceptor> acceptor_;
    std::unordered_map<int, TcpConnectionPtr> connections_;
    std::shared_ptr<ThreadPool> thread_pool_;
};
```

**æ€§èƒ½å…³é”®è®¾è®¡**ï¼š
1. **One Loop Per Thread**ï¼šæ¯ä¸ªIOçº¿ç¨‹ç‹¬ç«‹è¿è¡Œäº‹ä»¶å¾ªç¯
2. **é›¶æ‹·è´ä¼˜åŒ–**ï¼šä½¿ç”¨ `sendfile` æˆ– `splice` ä¼ è¾“å¤§æ–‡ä»¶
3. **ç¼“å†²åŒºè®¾è®¡**ï¼š
   ```cpp
   class Buffer {
   public:
       void append(const char* data, size_t len) {
           if (writable_bytes() < len) {
               makeSpace(len);
           }
           std::copy(data, data + len, begin() + writer_index_);
           writer_index_ += len;
       }

       void retrieve(size_t len) {
           if (len < readable_bytes()) {
               reader_index_ += len;
           } else {
               reader_index_ = writer_index_ = 0;
           }
       }

   private:
       std::vector<char> buffer_;
       size_t reader_index_ = 0;
       size_t writer_index_ = 0;
   };
   ```

---

#### **4. ç»¼åˆåº”ç”¨ï¼šæ„å»ºEchoæœåŠ¡å™¨**
```cpp
int main() {
    EventLoop main_loop;
    InetAddress listen_addr(8888);
    TcpServer server(&main_loop, listen_addr);

    server.SetConnectionCallback([](const TcpConnectionPtr& conn) {
        if (conn->Connected()) {
            conn->Send("Welcome to Echo Server\n");
        }
    });

    server.SetMessageCallback([](const TcpConnectionPtr& conn, Buffer* buf) {
        std::string msg(buf->peek(), buf->readable_bytes());
        conn->Send(msg);
        buf->retrieveAll();
    });

    server.Start(4); // å¯åŠ¨4ä¸ªIOçº¿ç¨‹
    main_loop.Loop();
}
```

---

#### **5. æ€§èƒ½ä¼˜åŒ–ç»ˆææ­¦å™¨**
1. **CPUäº²å’Œæ€§**ï¼šç»‘å®šçº¿ç¨‹åˆ°ç‰¹å®šæ ¸å¿ƒ
   ```cpp
   cpu_set_t cpuset;
   CPU_ZERO(&cpuset);
   CPU_SET(core_id, &cpuset);
   pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
   ```

2. **RDMAåŠ é€Ÿ**ï¼šåœ¨InfiniBandç½‘ç»œä¸­ä½¿ç”¨è¿œç¨‹ç›´æ¥å†…å­˜è®¿é—®
3. **DPDK/XDP**ï¼šç”¨æˆ·æ€ç½‘ç»œåè®®æ ˆç»•è¿‡å†…æ ¸

---

### **æ€»ç»“ï¼šé«˜æ€§èƒ½ç¼–ç¨‹çš„é»„é‡‘ä¸‰è§’**
| **ç»„ä»¶**      | **å…³é”®æŒ‡æ ‡**             | **é€‚ç”¨åœºæ™¯**                 |
|---------------|--------------------------|-----------------------------|
| **å†…å­˜æ± **    | åˆ†é…é€Ÿåº¦ã€ç¢ç‰‡ç‡         | é«˜é¢‘å¯¹è±¡åˆ›å»ºï¼ˆå¦‚æ¸¸æˆå®ä½“ï¼‰    |
| **çº¿ç¨‹æ± **    | ä»»åŠ¡ååé‡ã€å“åº”å»¶è¿Ÿ     | è®¡ç®—å¯†é›†å‹ä»»åŠ¡å¹¶è¡ŒåŒ–          |
| **ç½‘ç»œåº“**    | QPSã€è¿æ¥æ•°ã€å»¶è¿Ÿ         | é«˜å¹¶å‘æœåŠ¡å™¨ï¼ˆå¦‚WebæœåŠ¡ï¼‰     |

**è®¾è®¡å“²å­¦**ï¼š
- **èµ„æºå¤ç”¨ä¼˜äºé‡å¤åˆ›å»º**
- **æ•°æ®å±€éƒ¨æ€§ä¼˜äºéšæœºè®¿é—®**
- **å¼‚æ­¥éé˜»å¡ä¼˜äºåŒæ­¥é˜»å¡**

æŒæ¡è¿™äº›æ ¸å¿ƒç»„ä»¶çš„å®ç°ï¼Œä½ å°†æˆä¸ºçœŸæ­£çš„ç³»ç»Ÿçº§ç¼–ç¨‹é«˜æ‰‹ï¼ ğŸš€