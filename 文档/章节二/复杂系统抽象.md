
# å¤æ‚ç³»ç»ŸæŠ½è±¡

## æ¥å£è®¾è®¡

---

### **C++ æ¥å£è®¾è®¡è‰ºæœ¯ï¼šæŠ½è±¡ç±» vs æ¦‚å¿µï¼ˆConceptsï¼‰â€”â€” æ‰“é€ é»„é‡‘æ¨¡å—è¾¹ç•Œ**

---

#### **1. æ¥å£è®¾è®¡çš„æ ¸å¿ƒå“²å­¦**
**è®¾è®¡ç›®æ ‡**ï¼š
- **è§£è€¦**ï¼šæ¨¡å—é—´é€šè¿‡æŠ½è±¡æ¥å£é€šä¿¡ï¼Œè€Œéå…·ä½“å®ç°
- **å¯æ‰©å±•æ€§**ï¼šæ–°å¢åŠŸèƒ½æ— éœ€ä¿®æ”¹è°ƒç”¨æ–¹ä»£ç 
- **å¯æµ‹è¯•æ€§**ï¼šé€šè¿‡ Mock å®ç°å¿«é€Ÿå•å…ƒæµ‹è¯•
- **å¤šæ€æ”¯æŒ**ï¼šè¿è¡Œæ—¶åŠ¨æ€æ›¿æ¢å®ç°ï¼ˆæŠ½è±¡ç±»ï¼‰ / ç¼–è¯‘æœŸé™æ€åˆ†å‘ï¼ˆæ¦‚å¿µï¼‰

**å…³é”®åŸåˆ™**ï¼š
```
1. ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDIPï¼‰
   â†’ é«˜å±‚æ¨¡å—ä¸åº”ä¾èµ–ä½å±‚æ¨¡å—ï¼ŒäºŒè€…éƒ½ä¾èµ–æŠ½è±¡
2. æ¥å£éš”ç¦»åŸåˆ™ï¼ˆISPï¼‰
   â†’ å¤šä¸ªä¸“ç”¨æ¥å£ä¼˜äºå•ä¸€è‡ƒè‚¿æ¥å£
3. é‡Œæ°æ›¿æ¢åŸåˆ™ï¼ˆLSPï¼‰
   â†’ æ´¾ç”Ÿç±»å¿…é¡»èƒ½æ›¿æ¢åŸºç±»è€Œä¸ç ´åé€»è¾‘
```

---

#### **2. æŠ½è±¡ç±»ï¼ˆAbstract Classï¼‰â€”â€” è¿è¡Œæ—¶çš„å¤šæ€å¥‘çº¦**
**å…¸å‹åœºæ™¯**ï¼š
- éœ€è¦è¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢å®ç°ï¼ˆå¦‚æ’ä»¶ç³»ç»Ÿï¼‰
- è·¨äºŒè¿›åˆ¶æ¨¡å—ï¼ˆDLL/SOï¼‰çš„æ¥å£å®šä¹‰
- é¢å‘å¯¹è±¡æ¡†æ¶è®¾è®¡

**ä»£ç ç¤ºä¾‹ï¼šè·¨å¹³å°æ–‡ä»¶ç³»ç»Ÿæ¥å£**
```cpp
// æŠ½è±¡æ¥å£ï¼šå®šä¹‰æ¨¡å—èƒ½åŠ›
class IFileSystem {
public:
    virtual ~IFileSystem() = default;
    virtual std::vector<uint8_t> ReadFile(const std::string& path) = 0;
    virtual bool WriteFile(const std::string& path, const std::vector<uint8_t>& data) = 0;
    virtual std::string GetPlatformName() const = 0;
};

// å…·ä½“å®ç°ï¼šWindows æ–‡ä»¶ç³»ç»Ÿ
class WindowsFileSystem : public IFileSystem {
public:
    std::vector<uint8_t> ReadFile(const std::string& path) override {
        // è°ƒç”¨ Win32 API...
    }
    // å…¶ä»–æ–¹æ³•å®ç°...
};

// å®¢æˆ·ç«¯ä»£ç åªä¾èµ–æŠ½è±¡
class GameEngine {
public:
    GameEngine(std::unique_ptr<IFileSystem> fs) : fs_(std::move(fs)) {}

    void LoadAssets() {
        auto data = fs_->ReadFile("textures.dat");
        // ...
    }

private:
    std::unique_ptr<IFileSystem> fs_;
};

// ä½¿ç”¨ç¤ºä¾‹
auto engine = GameEngine(std::make_unique<WindowsFileSystem>());
```

**ä¼˜åŠ¿**ï¼š
- è¿è¡Œæ—¶åŠ¨æ€ç»‘å®šå®ç°
- æ˜ç¡®çš„è™šå‡½æ•°è¡¨ï¼ˆvtableï¼‰ï¼Œæ˜“äºè°ƒè¯•
- ABI ç¨³å®šï¼Œé€‚åˆè·¨ DLL è°ƒç”¨

**ç¼ºé™·**ï¼š
- è™šå‡½æ•°è°ƒç”¨å¼€é”€ï¼ˆçº³ç§’çº§ï¼Œä½†é«˜é¢‘è°ƒç”¨éœ€æ³¨æ„ï¼‰
- æ¥å£ä¿®æ”¹ä¼šå¯¼è‡´æ‰€æœ‰æ´¾ç”Ÿç±»å¿…é¡»æ›´æ–°

---

#### **3. æ¦‚å¿µï¼ˆConceptsï¼‰â€”â€” ç¼–è¯‘æœŸçš„é™æ€å¥‘çº¦**
**C++20 æ–°æ­¦å™¨**ï¼š
- åœ¨ç¼–è¯‘æœŸçº¦æŸæ¨¡æ¿ç±»å‹å¿…é¡»æ»¡è¶³çš„æ¥å£
- æ¯” SFINAE æ›´æ¸…æ™°ï¼Œé”™è¯¯ä¿¡æ¯æ›´å‹å¥½

**å…¸å‹åœºæ™¯**ï¼š
- æ³›å‹ç®—æ³•çº¦æŸï¼ˆå¦‚è¦æ±‚ç±»å‹æ”¯æŒ `operator<`ï¼‰
- é«˜æ€§èƒ½æ¨¡æ¿åº“è®¾è®¡
- ç¼–è¯‘æœŸå¤šæ€éœ€æ±‚

**ä»£ç ç¤ºä¾‹ï¼šæ•°å­¦åº“å‘é‡ç±»å‹çº¦æŸ**
```cpp
// å®šä¹‰æ¦‚å¿µï¼šè¦æ±‚ç±»å‹æ”¯æŒåŠ å‡å’Œæ ‡é‡ä¹˜æ³•
template<typename T>
concept VectorSpace = requires(T a, float scalar) {
    { a + a } -> std::same_as<T>;    // åŠ æ³•è¿”å›åŒç±»å‹
    { a - a } -> std::same_as<T>;
    { a * scalar } -> std::same_as<T>;
    { scalar * a } -> std::same_as<T>;
};

// æ³›å‹ç‚¹ç§¯å‡½æ•°
template<VectorSpace V>
auto DotProduct(const V& a, const V& b) {
    return (a + b) * 0.5f; // ç¤ºä¾‹æ“ä½œ
}

// å…·ä½“ç±»å‹
struct Vec3 {
    Vec3 operator+(const Vec3&) const;
    // å…¶ä»–è¿ç®—ç¬¦...
};

// ä½¿ç”¨
Vec3 v1, v2;
auto result = DotProduct(v1, v2); // ç¼–è¯‘é€šè¿‡

struct BadVec {};
// auto bad = DotProduct(BadVec{}, BadVec{}); // ç¼–è¯‘é”™è¯¯ï¼šä¸æ»¡è¶³æ¦‚å¿µ
```

**ä¼˜åŠ¿**ï¼š
- é›¶è¿è¡Œæ—¶å¼€é”€ï¼ˆçº¯ç¼–è¯‘æœŸæ£€æŸ¥ï¼‰
- æ”¯æŒå€¼è¯­ä¹‰ç±»å‹ï¼ˆæ— éœ€ç»§æ‰¿ä½“ç³»ï¼‰
- é”™è¯¯ä¿¡æ¯æ¸…æ™°ï¼ˆç›´æ¥æŒ‡å‡ºè¿åçš„æ¦‚å¿µæ¡æ¬¾ï¼‰

**ç¼ºé™·**ï¼š
- éœ€è¦ C++20 æ”¯æŒ
- æ¥å£å˜åŠ¨å¯èƒ½å¯¼è‡´æ¨¡æ¿å®ä¾‹åŒ–å¤±è´¥
- æ— æ³•å®ç°è¿è¡Œæ—¶åŠ¨æ€æ›¿æ¢

---

#### **4. åŒå‰‘åˆç’§ â€”â€” æŠ½è±¡ç±»ä¸æ¦‚å¿µçš„æ··åˆä½¿ç”¨**
**åœºæ™¯**ï¼šéœ€è¦åŒæ—¶æ”¯æŒè¿è¡Œæ—¶å¤šæ€å’Œæ³›å‹ç®—æ³•

**ä»£ç ç¤ºä¾‹ï¼šå¯åºåˆ—åŒ–ç³»ç»Ÿçš„æ··åˆè®¾è®¡**
```cpp
// æŠ½è±¡åŸºç±»ï¼šè¿è¡Œæ—¶å¤šæ€æ¥å£
class ISerializable {
public:
    virtual ~ISerializable() = default;
    virtual std::string ToString() const = 0;
};

// æ¦‚å¿µï¼šç¼–è¯‘æœŸåºåˆ—åŒ–çº¦æŸ
template<typename T>
concept Serializable = requires(const T& obj) {
    { obj.Serialize() } -> std::convertible_to<std::string>;
};

// æ³›å‹æ ¼å¼åŒ–å‡½æ•°ï¼ˆå…¼å®¹ä¸¤ç§æ–¹å¼ï¼‰
template<typename T>
std::string FormatData(const T& data) {
    if constexpr (std::derived_from<T, ISerializable>) {
        return data.ToString();  // è¿è¡Œæ—¶å¤šæ€
    } else if constexpr (Serializable<T>) {
        return data.Serialize(); // ç¼–è¯‘æœŸæ¦‚å¿µ
    } else {
        static_assert(false, "ä¸æ”¯æŒçš„åºåˆ—åŒ–ç±»å‹");
    }
}

// å…·ä½“å®ç°1ï¼šé€šè¿‡ç»§æ‰¿
class Player : public ISerializable {
public:
    std::string ToString() const override { return "Player"; }
};

// å…·ä½“å®ç°2ï¼šé€šè¿‡æ¦‚å¿µ
struct Weapon {
    std::string Serialize() const { return "Weapon"; }
};

// ä½¿ç”¨
Player p;
Weapon w;
std::cout << FormatData(p); // è°ƒç”¨ ToString()
std::cout << FormatData(w); // è°ƒç”¨ Serialize()
```

---

#### **5. æ¥å£è®¾è®¡æ¨¡å¼ä¸æŠ€å·§**
**æ¨¡å¼ 1ï¼šæ¡¥æ¥æ¨¡å¼ï¼ˆBridgeï¼‰**
```cpp
// æŠ½è±¡éƒ¨åˆ†
class Window {
public:
    explicit Window(class WindowImpl* impl) : impl_(impl) {}
    virtual void Draw() = 0;
protected:
    WindowImpl* impl_;
};

// å®ç°éƒ¨åˆ†
class WindowImpl {
public:
    virtual void DrawRect() = 0;
};

// å…·ä½“å®ç°
class WindowsWindowImpl : public WindowImpl { /*...*/ };
class MacWindowImpl : public WindowImpl { /*...*/ };
```

**æ¨¡å¼ 2ï¼šç­–ç•¥æ¨¡å¼ï¼ˆConcepts ç‰ˆï¼‰**
```cpp
template<typename T>
concept RenderingStrategy = requires(T s, const Scene& scene) {
    { s.Render(scene) } -> std::same_as<void>;
};

class GameEngine {
public:
    template<RenderingStrategy Strategy>
    void SetRenderer(Strategy&& s) {
        renderer_ = std::forward<Strategy>(s);
    }

    void RenderFrame() {
        renderer_.Render(currentScene_);
    }

private:
    Scene currentScene_;
    std::any renderer_; // éœ€è¦C++17
};
```

**æŠ€å·§ï¼šæ¥å£ç‰ˆæœ¬æ§åˆ¶**
```cpp
// æŠ½è±¡ç±»æ·»åŠ ç‰ˆæœ¬å·
class IAudioDevice {
public:
    static constexpr int INTERFACE_VERSION = 2;
    virtual void PlaySound(int id) = 0;
    virtual void SetVolume(float) = 0; // v2æ–°å¢
};

// ä½¿ç”¨æ—¶æ£€æŸ¥ç‰ˆæœ¬
if (device->INTERFACE_VERSION < 2) {
    // å›é€€åˆ°æ—§ç‰ˆAPI
}
```

---

#### **6. æ¥å£è®¾è®¡é»„é‡‘æ³•åˆ™**
1. **æœ€å°åŒ–æ¥å£**
   ```cpp
   // é”™è¯¯ï¼šæš´éœ²å®ç°ç»†èŠ‚
   class ICamera {
       virtual void SetMatrix(float[16]) = 0;
   };

   // æ­£ç¡®ï¼šé¢å‘è¡Œä¸º
   class ICamera {
       virtual void LookAt(const Vec3& pos, const Vec3& target) = 0;
   };
   ```

2. **ç±»å‹æ˜ç¡®**
   ```cpp
   // é”™è¯¯ï¼šæ¨¡ç³Šçš„è¿”å›ç±»å‹
   virtual int SaveData() = 0;

   // æ­£ç¡®ï¼šæ˜ç¡®è¯­ä¹‰
   virtual FileHandle SaveData(const std::string& path) = 0;
   ```

3. **å¼‚å¸¸å®‰å…¨**
   ```cpp
   // æ˜ç¡®å¼‚å¸¸çº¦å®š
   virtual void* Allocate(size_t size) noexcept = 0;
   virtual void Connect() /*å¯èƒ½æŠ›ç½‘ç»œå¼‚å¸¸*/ = 0;
   ```

4. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**
   ```cpp
   // æ˜ç¡®æ‰€æœ‰æƒä¼ é€’
   virtual std::unique_ptr<Texture> CreateTexture() = 0;
   ```

---

### **æ€»ç»“ï¼šé€‰æ‹©æŠ½è±¡ç±»è¿˜æ˜¯æ¦‚å¿µï¼Ÿ**
| **ç»´åº¦**           | **æŠ½è±¡ç±»**                    | **æ¦‚å¿µ**                      |
|---------------------|-------------------------------|-------------------------------|
| å¤šæ€ç±»å‹            | è¿è¡Œæ—¶                        | ç¼–è¯‘æ—¶                        |
| æ€§èƒ½                | è™šå‡½æ•°è°ƒç”¨å¼€é”€                | é›¶å¼€é”€ï¼Œå¯èƒ½å†…è”ä¼˜åŒ–          |
| ç±»å‹å…³ç³»            | å¿…é¡»ç»§æ‰¿                      | é¸­å­ç±»å‹ï¼ˆDuck Typingï¼‰        |
| äºŒè¿›åˆ¶å…¼å®¹          | å®¹æ˜“ï¼ˆvtable å›ºå®šåç§»ï¼‰       | éœ€è¦å¤´æ–‡ä»¶å¯è§                |
| å…¸å‹åº”ç”¨            | æ’ä»¶ç³»ç»Ÿã€è·¨æ¨¡å—è°ƒç”¨          | æ³›å‹ç®—æ³•ã€æ•°å­¦åº“              |
| æ¥å£æ¼”åŒ–            | ä¿®æ”¹éœ€é‡æ–°ç¼–è¯‘æ‰€æœ‰æ´¾ç”Ÿç±»      | æ—§ç±»å‹è‡ªåŠ¨æ»¡è¶³æ–°æ¦‚å¿µï¼ˆè‹¥åŒ¹é…ï¼‰|

**ç»ˆææ³•åˆ™**ï¼š
- éœ€è¦ **è¿è¡Œæ—¶åŠ¨æ€æ›¿æ¢** â†’ æŠ½è±¡ç±»
- éœ€è¦ **é«˜æ€§èƒ½æ³›å‹ç¼–ç¨‹** â†’ æ¦‚å¿µ
- å¤§å‹ç³»ç»Ÿ â†’ **æ··åˆä½¿ç”¨**ï¼ŒæŠ½è±¡ç±»å®šä¹‰æ¨¡å—è¾¹ç•Œï¼Œæ¦‚å¿µçº¦æŸå†…éƒ¨ç®—æ³•

è®©æ¥å£å¦‚åŒç²¾å¯†çš„é½¿è½® â€”â€” **ä¸¥ä¸åˆç¼çš„å¥‘çº¦ï¼Œé©±åŠ¨ç³»ç»Ÿä¼˜é›…è¿è½¬ï¼** âš™ï¸

## æ¨¡å—åŒ–ä¸è§£è€¦



---

### **C++ æ¨¡å—åŒ–ä¸è§£è€¦æŒ‡å—ï¼šåŠ¨æ€åº“ vs é™æ€åº“ â€”â€” æ„å»ºçµæ´»å¦‚ä¹é«˜çš„ç³»ç»Ÿï¼**

---

#### **1. åº“çš„æœ¬è´¨ä¸æ ¸å¿ƒå·®å¼‚**
**é™æ€åº“ï¼ˆ.a/.libï¼‰**
- **é“¾æ¥æ—¶æœº**ï¼šç¼–è¯‘æœŸç›´æ¥åµŒå…¥å¯æ‰§è¡Œæ–‡ä»¶
- **æ–‡ä»¶ç»„æˆ**ï¼šäºŒè¿›åˆ¶ä»£ç  + ç¬¦å·è¡¨
- **å…¸å‹åº”ç”¨**ï¼šåŸºç¡€å·¥å…·åº“ï¼ˆå¦‚æ•°å­¦åº“ï¼‰ã€åµŒå…¥å¼å¼€å‘
- **ä¼˜åŠ¿**ï¼š
  - æ— è¿è¡Œæ—¶ä¾èµ–
  - ç¼–è¯‘ä¼˜åŒ–æ›´å½»åº•ï¼ˆLTOï¼‰
- **ç¼ºé™·**ï¼š
  - å¯æ‰§è¡Œæ–‡ä»¶ä½“ç§¯è†¨èƒ€
  - æ›´æ–°éœ€é‡æ–°ç¼–è¯‘æ•´ä¸ªé¡¹ç›®

**åŠ¨æ€åº“ï¼ˆ.so/.dllï¼‰**
- **é“¾æ¥æ—¶æœº**ï¼šè¿è¡Œæ—¶åŠ¨æ€åŠ è½½
- **æ–‡ä»¶ç»„æˆ**ï¼šä½ç½®æ— å…³ä»£ç ï¼ˆPICï¼‰ + å¯¼å‡ºç¬¦å·è¡¨
- **å…¸å‹åº”ç”¨**ï¼šæ’ä»¶ç³»ç»Ÿã€å¤§å‹åº”ç”¨æ¨¡å—ï¼ˆå¦‚æ¸¸æˆå¼•æ“æ¸²æŸ“æ¨¡å—ï¼‰
- **ä¼˜åŠ¿**ï¼š
  - å¤šè¿›ç¨‹å…±äº«å†…å­˜ä¸­çš„ä»£ç 
  - æ”¯æŒçƒ­æ›´æ–°ï¼ˆæ›¿æ¢.dllæ— éœ€é‡æ–°ç¼–è¯‘ä¸»ç¨‹åºï¼‰
- **ç¼ºé™·**ï¼š
  - å­˜åœ¨DLL Hellé£é™©ï¼ˆç‰ˆæœ¬å†²çªï¼‰
  - éœ€è¦å¤„ç†ç¬¦å·å¯è§æ€§

---

#### **2. å®æˆ˜ï¼šæ„å»ºè·¨å¹³å°åŠ¨æ€åº“**
**æ­¥éª¤ 1ï¼šå®šä¹‰ç¨³å®šæ¥å£ï¼ˆå¤´æ–‡ä»¶ï¼‰**
```cpp
// math_interface.h
#pragma once

#ifdef _WIN32
    #ifdef MATH_EXPORTS
        #define MATH_API __declspec(dllexport)
    #else
        #define MATH_API __declspec(dllimport)
    #endif
#else
    #define MATH_API __attribute__((visibility("default")))
#endif

class MATH_API IMathLib {
public:
    virtual ~IMathLib() = default;
    virtual double Sqrt(double x) = 0;
    virtual int Add(int a, int b) = 0;
};

// å·¥å‚å‡½æ•°ï¼ˆå¿…é¡»extern "C"é¿å…åç§°ç²‰ç¢ï¼‰
extern "C" MATH_API IMathLib* CreateMathLib();
```

**æ­¥éª¤ 2ï¼šå®ç°åŠ¨æ€åº“ï¼ˆLinuxç¤ºä¾‹ï¼‰**
```cpp
// math_linux.cpp
#include "math_interface.h"

class MathLib : public IMathLib {
public:
    double Sqrt(double x) override {
        // ä½¿ç”¨SSEæŒ‡ä»¤ä¼˜åŒ–
        __m128d val = _mm_set_sd(x);
        __m128d res = _mm_sqrt_sd(val, val);
        return _mm_cvtsd_f64(res);
    }

    int Add(int a, int b) override {
        return a + b;
    }
};

extern "C" IMathLib* CreateMathLib() {
    return new MathLib();
}
```

**ç¼–è¯‘å‘½ä»¤ï¼ˆLinuxï¼‰**ï¼š
```bash
g++ -fPIC -shared math_linux.cpp -o libmath.so -msse4
```

**ç¼–è¯‘å‘½ä»¤ï¼ˆWindowsï¼‰**ï¼š
```powershell
cl /LD math_win.cpp /Fe:math.dll /link /EXPORT:CreateMathLib
```

---

#### **3. åŠ¨æ€åº“åŠ è½½çš„ä¸‰ç§å§¿åŠ¿**
**æ–¹å¼ 1ï¼šéšå¼é“¾æ¥ï¼ˆç¼–è¯‘æ—¶ç»‘å®šï¼‰**
```cpp
// main.cpp
#include "math_interface.h"

int main() {
    IMathLib* lib = CreateMathLib();
    int sum = lib->Add(3, 4);
    delete lib;
    return 0;
}

// ç¼–è¯‘å‘½ä»¤ï¼ˆéœ€é“¾æ¥.lib/.soï¼‰
g++ main.cpp -o main -L. -lmath
```

**æ–¹å¼ 2ï¼šæ˜¾å¼åŠ è½½ï¼ˆè¿è¡Œæ—¶åŠ¨æ€ç»‘å®šï¼‰**
```cpp
#include <dlfcn.h> // Windowsç”¨LoadLibrary/GetProcAddress

void* handle = dlopen("./libmath.so", RTLD_LAZY);
auto create_func = (IMathLib*(*)())dlsym(handle, "CreateMathLib");
IMathLib* lib = create_func();

// ä½¿ç”¨åæ¸…ç†
lib->Release();
dlclose(handle);
```

**æ–¹å¼ 3ï¼šæ··åˆæ¨¡å¼ï¼ˆæ¥å£ä»£ç†ï¼‰**
```cpp
class MathProxy {
public:
    MathProxy() {
        #ifdef USE_DYNAMIC_LOAD
            handle_ = dlopen("libmath.so", RTLD_LAZY);
            create_ = (CreateFunc)dlsym(handle_, "CreateMathLib");
        #endif
        impl_ = create_();
    }

    ~MathProxy() {
        delete impl_;
        #ifdef USE_DYNAMIC_LOAD
            dlclose(handle_);
        #endif
    }

    int Add(int a, int b) { return impl_->Add(a, b); }

private:
    IMathLib* impl_;
    void* handle_;
    using CreateFunc = IMathLib*(*)();
    CreateFunc create_;
};
```

---

#### **4. æ¨¡å—è§£è€¦çš„ä¸ƒå¤§é»„é‡‘æ³•åˆ™**
1. **æ¥å£ç¨³å®š**ï¼š
   - ä½¿ç”¨çº¯è™šæ¥å£ç±»ï¼ˆæ— æ•°æ®æˆå‘˜ï¼‰
   - ç‰ˆæœ¬æ§åˆ¶ï¼ˆå¦‚ `IMathLibV2`ï¼‰

2. **éšè—å®ç°ç»†èŠ‚**ï¼š
   ```cpp
   // é”™è¯¯ï¼šå¯¼å‡ºå…·ä½“ç±»
   class MATH_API Vector3 { /*...*/ };

   // æ­£ç¡®ï¼šä»…å¯¼å‡ºæ¥å£
   class MATH_API IVector {
       virtual float X() = 0;
       virtual void SetX(float) = 0;
   };
   ```

3. **å·¥å‚æ¨¡å¼éš”ç¦»æ„é€ **ï¼š
   ```cpp
   // å·¥å‚æ¥å£å£°æ˜
   extern "C" MATH_API IModule* CreateModule(int version);
   ```

4. **ABIå…¼å®¹æ€§**ï¼š
   - é¿å…STLå®¹å™¨è·¨è¾¹ç•Œä¼ é€’ï¼ˆä½¿ç”¨åŸå§‹æŒ‡é’ˆ+é•¿åº¦ï¼‰
   - ç¦ç”¨å¼‚å¸¸è·¨è¾¹ç•Œä¼ æ’­

5. **ä¾èµ–å€’ç½®**ï¼š
   ```cpp
   // é”™è¯¯ï¼šé«˜å±‚æ¨¡å—ä¾èµ–å…·ä½“å®ç°
   class Game {
       PhysicsEngine physics; // ç›´æ¥åŒ…å«å…·ä½“ç±»
   };

   // æ­£ç¡®ï¼šä¾èµ–æŠ½è±¡æ¥å£
   class Game {
       std::unique_ptr<IPhysicsEngine> physics;
   };
   ```

6. **ç¬¦å·å¯è§æ€§æ§åˆ¶**ï¼ˆGCCï¼‰ï¼š
   ```cpp
   // æ˜¾å¼å¯¼å‡ºç¬¦å·
   __attribute__((visibility("default"))) void Foo();

   // ç¼–è¯‘é€‰é¡¹ï¼šéšè—æ‰€æœ‰ç¬¦å·ï¼Œä»…æ˜¾å¼å¯¼å‡º
   -fvisibility=hidden
   ```

7. **é˜²å¾¡æ€§ç¼–ç¨‹**ï¼š
   ```cpp
   // æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
   IModule* module = CreateModule();
   if (module->GetVersion() != EXPECTED_VERSION) {
       // ä¼˜é›…é™çº§æˆ–æŠ¥é”™
   }
   ```

---

#### **5. ç°ä»£æ„å»ºç³»ç»Ÿé›†æˆï¼ˆCMakeç¤ºä¾‹ï¼‰**
**åŠ¨æ€åº“é…ç½®**ï¼š
```cmake
# ç”ŸæˆåŠ¨æ€åº“
add_library(math SHARED math.cpp)
target_compile_definitions(math PRIVATE MATH_EXPORTS)
set_target_properties(math PROPERTIES
    CXX_VISIBILITY_PRESET hidden
    VISIBILITY_INLINES_HIDDEN 1
)

# ä¸»ç¨‹åºé“¾æ¥
add_executable(main main.cpp)
target_link_libraries(main PRIVATE math)
```

**è·¨å¹³å°ç¬¦å·å¯¼å‡º**ï¼š
```cmake
# è‡ªåŠ¨ç”Ÿæˆå¯¼å‡ºå®
include(GenerateExportHeader)
generate_export_header(math
    BASE_NAME MATH
    EXPORT_MACRO_NAME MATH_API
)
```

**å®‰è£…è§„åˆ™**ï¼š
```cmake
install(TARGETS math
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)
```

---

#### **6. æ¨¡å—åŒ–å®æˆ˜ï¼šæ’ä»¶ç³»ç»Ÿæ¶æ„**
**æ¶æ„å›¾**ï¼š
```
+-------------------+    åŠ¨æ€åŠ è½½     +-------------------+
|   ä¸»ç¨‹åºæ ¸å¿ƒ       |â—„---[dlopen]----|   æ’ä»¶æ¨¡å—         |
|                   |                |ï¼ˆå®ç°ICameraPluginï¼‰
+-------------------+                +-------------------+
| - æ’ä»¶ç®¡ç†å™¨       |                | - å®ç°å…·ä½“ç®—æ³•     |
| - äº‹ä»¶æ€»çº¿         |                +-------------------+
+-------------------+
```

**æ’ä»¶æ¥å£è®¾è®¡**ï¼š
```cpp
// camera_plugin.h
class ICameraPlugin {
public:
    virtual ~ICameraPlugin() = default;
    virtual void Initialize() = 0;
    virtual void RenderFrame() = 0;
    virtual const char* GetName() = 0;
};

// å¯¼å‡ºç¬¦å·
extern "C" {
    CAMERA_API ICameraPlugin* CreatePlugin();
    CAMERA_API void DestroyPlugin(ICameraPlugin*);
}
```

**æ’ä»¶çƒ­åŠ è½½ç¤ºä¾‹**ï¼š
```cpp
class PluginHotLoader {
public:
    void Reload(const std::string& path) {
        Unload();
        handle_ = dlopen(path.c_str(), RTLD_NOW);
        auto create = (CreateFunc)dlsym(handle_, "CreatePlugin");
        plugin_ = create();
    }

    void Unload() {
        if (plugin_) {
            auto destroy = (DestroyFunc)dlsym(handle_, "DestroyPlugin");
            destroy(plugin_);
            dlclose(handle_);
        }
    }

private:
    ICameraPlugin* plugin_;
    void* handle_;
};
```

---

#### **7. æ€§èƒ½ä¸ç»´æŠ¤çš„å¹³è¡¡æœ¯**
**é€‰æ‹©é™æ€åº“çš„åœºæ™¯**ï¼š
- å…³é”®æ€§èƒ½è·¯å¾„ï¼ˆå…è®¸LTOä¼˜åŒ–ï¼‰
- åµŒå…¥å¼è®¾å¤‡ï¼ˆæ— åŠ¨æ€åŠ è½½ç¯å¢ƒï¼‰
- ç¬¬ä¸‰æ–¹é—­æºç»„ä»¶åˆ†å‘

**é€‰æ‹©åŠ¨æ€åº“çš„åœºæ™¯**ï¼š
- å¤§å‹æ¨¡å—éœ€è¦ç‹¬ç«‹æ›´æ–°ï¼ˆå¦‚æ¸¸æˆDLCï¼‰
- å¤šè¿›ç¨‹å…±äº«ä»£ç ï¼ˆå¦‚ç³»ç»ŸåŸºç¡€åº“glibcï¼‰
- æ’ä»¶åŒ–æ¶æ„éœ€æ±‚

**æ··åˆæ¶æ„ç¤ºä¾‹**ï¼š
```
åº”ç”¨ä¸»ä½“ï¼ˆé™æ€é“¾æ¥æ ¸å¿ƒæ¨¡å—ï¼‰
â”œâ”€â”€ æ¸²æŸ“å¼•æ“ï¼ˆåŠ¨æ€åº“ï¼Œæ”¯æŒå¤šåç«¯ï¼‰
â”œâ”€â”€ ç‰©ç†å¼•æ“ï¼ˆåŠ¨æ€åº“ï¼Œå¯æ›¿æ¢Bullet/Havokï¼‰
â””â”€â”€ è„šæœ¬ç³»ç»Ÿï¼ˆåŠ¨æ€åº“ï¼Œæ”¯æŒLua/Pythonï¼‰
```

---

### **æ€»ç»“ï¼šè®©ç³»ç»Ÿå¦‚ä¹é«˜èˆ¬è‡ªç”±æ‹¼è£…**
- **é™æ€åº“**ï¼šæ„å»ºç³»ç»ŸåŸºçŸ³ï¼Œæä¾›æè‡´æ€§èƒ½
- **åŠ¨æ€åº“**ï¼šå®ç°çµæ´»æ¶æ„ï¼Œæ”¯æŒçƒ­æ’æ‹”ç”Ÿæ€
- **æ ¸å¿ƒåŸåˆ™**ï¼š
  - **æ¥å£å³å¥‘çº¦**ï¼šç¨³å®šé«˜äºä¸€åˆ‡
  - **æœ€å°åŒ–ä¾èµ–**ï¼šé™ä½è€¦åˆå¤æ‚åº¦
  - **é˜²å¾¡æ€§è®¾è®¡**ï¼šå…¼å®¹ä¸åŒç‰ˆæœ¬å’Œç¯å¢ƒ

æŒæ¡æ¨¡å—åŒ–è‰ºæœ¯ï¼Œè®©ä»£ç åº“å¦‚åŒç²¾å¯†æœºæ¢° â€”â€” **æ¯ä¸ªé½¿è½®ç‹¬ç«‹è¿è½¬ï¼Œæ•´ä½“ç³»ç»Ÿè¡Œäº‘æµæ°´ï¼** ğŸ§©